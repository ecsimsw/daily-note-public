## E20240328 머릿속 트랜잭션 정리.md

머릿속 마구 정리

### 트랜잭션 
- 데이터를 처리하는 작업 단위

### ACID
- Atomic : 트랜잭션의 작업은 성공 or 실패여야한다.
- Consistency : 트랜잭션 처리 전과 후에도 규칙이 지켜져야한다.
- Isolation : 트랜잭션간 격리되어야 한다. 공통 자원은 동시에 여러 트랜잭션에서 처리되어선 안된다.
- Durabilty : 커밋된 내용은 영속되어 안전하게 기록되어야 한다.

### 트랜잭션간 격리를 지키지 못한다면
- 임계구역 (동시에 접근하는 데이터)에서 정합성 문제가 발생할 수 있다.

### 그럼 격리를 항상 지킬 수 있을까?
- 격리를 엄격하게 하면 동시성이 떨어진다.
- 트랜잭션의 격리 레벨에 따라 고립성을 달리하는 것으로 동시성과 안정성을 트레이드 오프한다.

### 격리 수준 
- Read uncommitted : 다른 트랜잭션의 커밋되지 않은 데이터를 읽어 작업하다가 해당 트랜잭션이 롤백되어 엉뚱한 값으로 처리한 꼴이 되는 dirty read 문제
- Read committed : 일단 커밋된 데이터를 읽기는 하나, 동일 데이터가 여러번 조회 될때 다른 결과 값을 갖는 문제 발생
- Repeatable read : 한 데이터에 있어서 여러 조회에 같은 값을 보장하지만, 범위 조회를 여러번 할 때에 없었던 데이터가 추가되는 팬텀 리드 문제 발생
- Serializable : 조회에 락을 사용하는 것으로 조회시 다른 트랜잭션에서 데이터 변경을 막아 팬텀 리드 문제를 개선

### Mysql 의 MVCC
- Mysql 은 트랜잭션 별로 한 데이터 안에서 서로 다른 버전을 처리할 수 있도록 하는 MVCC를 지원한다.
- 데이터에 수정이 일어나면 undo log 에 원본 값을 기록하고, 다른 트랜잭션은 이 undo log 의 여러 버전 중 본인이 필요한 값을 읽게된다.

### Mysql 의 버퍼 풀
- 데이터를 수정하면 바로 HDD에 반영하는게 아니라 버퍼 풀에 우선 저장한다.
- 실제 데이터를 수정한게 아니기에 버퍼만 날리면 롤백 처리를 하지 않아도 될 것이다.
- 쓰기 지연을 줘 쓰기 연산의 최종본만 처리하면 될 것이다.
- 테이블 데이터 뿐 아니라 인덱스 데이터 캐시도 처리된다. 

### 격리 수준별 MVCC
0. 두 트랜잭션이 동일한 데이터를 조회하고 있고, 그 값을 A 라고 해보자.
1. 외부 트랜잭션에서 값을 B로 업데이트하고 아직 Commit 하지 않았을 때
- Read uncommitted
  - 커밋되지 않은 값을 읽기에 MVCC에 의미가 없다. 
  - 그저 undo log 와 상관없이 버퍼 풀에 있는 변경된 데이터를 읽는다. -> B
- Read committed, Repeatable read 
  - undo log의 원본 값을 읽어 commit 된 데이터 조회를 보장한다. -> A
2. 외부 트랜잭션에서 Commit 을 처리했을 때
- Read committed 이하
  - 커밋된 값을 읽기에 이번엔 변경된 데이터를 읽는다 -> B (이전 조회와 다른 값을 갖는 Unrepeatable read 발생)
- Repeatable read
  - 본인 트랜잭션의 키 값으로 undo log 를 읽어 기존 조회 데이터와 동일한 조회를 보장한다. -> A
3. 현재 트랜잭션을 Commit 하면
- 더 이상 사용되지 않는 undo log 는 제거된다.
- 반대로 트랜잭션이 종료되지 않으면 undo log 가 제거되지 못하고 계속 자라는 문제가 생긴다.

### Mysql Next key lock 
- Mysql 의 repeatable read 에서 select ~ between 을 여러번 했다고 했을 때, 그 사이에 다른 트랜잭션에서 Between 사이에 데이터를 추가했다고 하자. 그 추가가 조회에 반영되는 팬텀 리드가 발생할까? 
- 정답은 발생하지 않는다. 동일한 로우 수로 처리된다.
- undo log 를 읽기 때문이다.

- 똑같은 repeatable read에서 select ~ between ~ for update 를 여러번 했다고 해보자. 같은 상황에서 팬텀 리드가 발생할까?
- select for X 로 락은 조회에 락을 거는 것으로 undo log 로 처리할 수 없기에, undo log 가 아닌 실제 값을 읽어야 한다.
- 그래서 undo log를 사용할 수 없다.

- 그럼 팬텀 리드가 발생할까? 발생하지 않는다. 앞선 조회 락에서 검색 조건을 범위로 next key lock 이 걸린다.
- next key lock 은 Row lock과 Gap lock 으로 검색 범위의 삽입, 삭제를 락으로 대기 시킨다. 

### 락을 이용한 격리 
- 배타락 : 다른 락과 함께 처리될 수 없음
- 공유락 : 공유락과는 함께 처리될 수 있지만 배타락과는 불가능

### 꼭 DB만 트랜잭션을 신경써? Application 의 역할 
- 원자성 : Transactional outbox, 예외 처리로 성공 or 실패 중 하나만 할 수 있도록
- 일관성 : 도메인이나 서비스에서도 데이터 규칙에 맞지 않는 처리가 나오지 않도록 유효성 검증
- 고립성 
   - DB 락이 아닌, 데이터 버전을 이용한 트랜잭션 격리 실패 검증과 그때의 재시도 처리 (낙관적 락),
   - 프로세스의 메모리, 언어 수준의 락을 활용한 로직 격리
   - 공유 자원 (레디스와 같은 공유 메모리, DB) 를 활용한 분산 환경에서의 락
- 영속성 : 처리한 내용을 파일이나 DB에 기록

### 데드락이 발생할 수 있는 상황 (내 경험)
- 읽기 락으로 여러 스레드가 동시에 공통 자원을 점유한 상황에서 그 자원을 수정하려고 하면
- 배타 락에 다른 스레드들이 읽기 락을 놔줘야 수정을 처리하는데 아무도 읽기 락을 해제하지 못하는 상황

### 네임드락
- 비관적 락처럼 테이블이나 Row 에 락을 거는게 아니라, DB의 메타데이터를 활용
- 락 자체에 타임 아웃을 걸 수 있음
- 트랜잭션과 별개로 락을 해제해야 하기 때문에 격리를 처리하고자 하는 작업 전후로 네임드락 시작/해제 필요

``` 
A transaction begin
try lock
// handle shared resource
release lock
A transaction commit
```

- 이렇게 처리하면 트랜잭션이 커밋되는 시점에서 락이 풀려있어 위험한 상황이 발생하기에

```
L transaction begin
try lock

A transaction begin
// handle shared resource
A transaction commit

release lock
L transaction commit
```

- 이렇게 작업의 트랜잭션이랑 분리하고 작업 트랜잭션을 전후에서 포함하는 식으로 많이 사용
- 이 경우 커넥션은 두개가 발생하고 트랜잭션 처리를 위한 코드도 번거로워지고 위험할 수 있으니 조심히 사용해야 할 듯.
- 근데 DB 외 다른 인프라를 추가하지 않고 분산 환경에서 락을 구현하고 싶으면 써볼만 할 것 같다.

### OSIV 와 트랜잭션
- open session in view 로, 영속성 컨텍스트를 뷰까지 끌고 서비스 범위 밖까지 영속 상태를 가져 Lazy loading 을 가능하게 한다.
- 이때 뷰에서 Lazy 로 처리되는 쿼리는 트랜잭션이 없이 처리된다.
- 영속성 컨텍스트가 뷰부터 DB까지로 길어짐에 따라 커넥션 점유 시간도 길어진다.
- 트랜잭션 없이 조회는 Read committed 랑 유사하다.
