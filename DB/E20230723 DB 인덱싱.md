# DB 인덱싱

머릿 속 마구 정리    

## Random I/O, Sequential I/O
특정 값을 조회하는 것과 연속 데이터를 읽는 것.   
순차 접근에는 SSD와 HDD의 차이가 적으나 Random I/O에서 SSD가 월등하다.    
그래서 하고 싶은 것은 HDD를 사용하기 쉬운 DB의 Random I/O를 가능한 Sequential I/O로 돌리는 것    

## 자료구조
인덱싱은 더 빠른 검색을 위해 공간을 더 사용해서 지정된 값들로 정렬된 자료를 따로 두는 것이다. InnoDB는 그 자료를 저장하는 방법으로 B+Tree를 사용한다.       

### BST 
Log(N), 한 쪽으로 쏠리면 N    

### AVR 
균형을 맞춤, 삽입/삭제에서 비용    

### B-tree 

탐색 트리이지만 BST에 더해 2개 이상의 노드도 가질 수 있다. 범위기반으로.    

<br>

![image](https://github.com/ecsimsw/daily-note-public/assets/46060746/d1380839-25b4-4427-b68d-4b3ea59dbf23)

### B+ tree 
  
1. B tree에 더해 리프노드끼리 더블 링크드리스트로 연결되어 있다. 그래서 특정 리프 ~ 특정 리프까지의 탐색에서 B tree보다 훨씬 우월하다.
2. 모든 노드에서 데이터 포인터를 갖는 B tree와 달리, 리프 노드에만 데이터 포인터를 갖고 있어 마지막 리프만 확인하면 되고 저장 공간으로 리프 노드를 늘릴 수 있어 cache hit율이 더 좋다.
  
![Btree](https://github.com/ecsimsw/daily-note-public/assets/46060746/74e3649b-a242-4896-9733-3e03f3a4e7d1)

## 인덱스 조회

### Index full scan
인덱스는 정의한 순서대로 정렬한다. (name -> price -> quantity)라면 딱 그 순서대로.    
그래서 위 인덱스 정의 후 price로 검색을 한다면 결국 모든 인덱스를 다 탐색해야 한다. (name, price)로 정렬 순서가 올바른 경우가 아니고 말이다.    
    
그 때 인덱스를 전부 검색하고 그 찾은 포인터로 다시 데이터 파일을 ranom access 해야 한다. 그래서 차라리 인덱스를 안타고 바로 테이블을 조회하는게 더 유리할 수 있다.    
보통 테이블의 20%~30%가 넘는 조건을 인덱스로 검색해야 한다면 그 땐 테이블 풀스캔이 유리하다고 한다. 물론 테이블을 안거치고 인덱스 검색만으로 조회가 끝나는 경우는 빼고다.     

### Covering index
검색의 모든 컬럼이 index 적용으로 인덱스 조회 후 데이터 파일을 엑세스 하지 않고 바로 응답할 수 있는 경우를 말한다.    
예를 들면 (name, price, quantity)로 인덱스가 적용된 상황에서 (name,price)를 쿼리하면 데이터 파일을 접근하지 않고 인덱스 조회만으로도 원하는 응답을 만들 수 있을 것이다.    

### Index range scan
인덱스에서 범위로 탐색을 하고, 데이터 파일을 엑세스 하는 경우를 말한다.    

### Loose / Skip index
인덱싱 조회에서 불필요한 확인을 피한다.     
예를 들면 (name, price, quantity)로 인덱스가 적용된 상태에서 이름 별 가장 작은 가격을 확인하는데 동일 이름 아래 price가 정렬된 상황이라면 굳이 가장 작은 값 외에 다른 값을 읽지 않아도 된다.     
이렇게 MIN/MAX나 검색 조건 범위에 따라 탐색이 불필요한 부분은 스킵하는 경우를 말한다.    

### 카디널리티 
중복도가 낮을 수록 높은 값을 갖는다. 성별은 카디널리티가 낮고, 이름은 높다.    
이름과 성별이 인덱스가 걸려있는 상황에서 이름이 김진환인 사람 중에 남자인 사람을 찾는 것과 남자인 사람을 찾고 그 중 김진환인 사람을 고르는 것 어떤게 더 효율적일까.    
카디널리티가 높은 컬럼을 인덱스로 고려하고, 높은 컬럼을 더 먼저 조회할 수 있도록 한다.    
