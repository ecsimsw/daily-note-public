## 블록킹과 논블록킹, 동기와 비동기 
블록킹, 논블록킹은 제어권/흐름을 뺏기는지 여부로, 동기와 비동기은 작업 완료를 기다리는지 여부로.

### 1. 제어권이 뺏긴다면 블록킹
블록킹은 다른 작업 호출 후 제어권이 뺏긴다. 예를들어 A에서 B를 호출했다고 할 때, B에게 제어권/흐름이 넘어가면 이는 블록킹이다. A는 꼼짝없이 B가 제어권을 다시 넘겨주기만을 기다려야 하는 것이다.       

반면 논블록킹은 다르다. 호출 후 제어권을 잃지 않는다. A가 B를 호출했다고 하더라도 여전히 흐름은 A 본인한테 있다.    

A, B 각각 10초가 걸리는 일이라고 가정해보자. A가 B를 호출했을 때, B가 중간에 다시 흐름을 놓지 않는 이상 10초 동안 B가 진행된다면 B는 블록킹으로 동작하는 것이다. 
반대로 B를 호출했을 때 A가 흐름을 잃지 않고 남은 작업을 처리하는 흐름을 갖을 수 있다면, B는 논블록킹으로 동작하는 것이다.


### 2. 작업 완료를 기다려야만 한다면 동기
동기는 다른 작업의 완료를 기다려야만 한다. 그 결과를 봐야지만 다음 흐름을 진행할 수 있다. 반면 비동기는 다른 작업의 완료에 상관없이 자신의 일을 처리한다.   

A, B가 각각 10초가 걸리는 일이라고 가정해보자. A가 B를 호출했을 때, A가 B의 리턴 값을 기다리는 순차 처리를 필요로 할 경우 이는 동기 처리이다.    
반면 A가 B의 리턴이나 순서에 전혀 무관하게 자신의 일을 처리한다면 비동기이다.

### 3. 각 시나리오

`동기 / 블록킹` : A가 B를 호출하면, 그 즉시 흐름은 B에게로 넘어가 B가 처리되고 A는 B의 흐름이 종료되기 전까지 자신의 흐름을 갖지 못하면서, 
'B의 결과가 결정됨 + 본인 흐름을 갖음' 그 후에 A가 이어서 작업된다.

`동기 / 논블록킹` : A가 B를 호출하는데, 흐름은 여전히 A에게 있되, B의 작업 완료/순서를 신경쓴다. A가 B를 호출해도 흐름은 A에게 여전히 있어    
A 흐름이 진행되는 동시에 B의 완료를 확인해야 하므로 A는 계속 B를 호출하여 B가 완료되었는지를 확인해야 한다.

`비동기 / 블록킹` : A가 B를 호출하는 순간 흐름은 B에게 있다. A는 B의 리턴 값에도, 처리 순서에도 영향을 받지 않지만 흐름이 B에 있어 이런 상황에서 A가 할 수 있는게 없다.

`비동기 / 논블록킹` : A가 B를 호출해도 흐름을 뺏기지 않는다. 그와 동시에 A는 B의 리턴 값이나 순서를 신경쓰지 않아도 된다. 말그대로 A는 B를 호출만 하고 자기 할일을 한다.
