## E20240327 머릿속 인덱스 정리하기.md

그저 머릿 속 정리. 

### 인덱스란
다른 자료 구조를 사용해서 검색 성능을 개선하는 데이터 저장 방식

### 인덱스의 자료구조
B+Tree, 해시

### 자료 구조들
- 해시 : 일반적인 상황에선 해시가 원본 데이터와 전혀 상관없을 값을 갖기 때문에 범위 탐색이 안되고 해시가 겹쳤을 때 Rehashing 이 비용이 큼 
- 이진 탐색 트리 : LogN으로 처리할 수 있기에 선형 탐색보다는 빠르나, 균형을 맞지 않는 경우 리스트와 같아질 수 있음
- AVL : 이진 탐색 트리에서 균형을 맞춤. 한 방향으로 쏠릴 걱정은 하지 않아도 되나, 균형을 맞추는데 비용이 듦
- B Tree : 한 노드에서 여러 값을 가져서 자식 노드의 개수가 2개가 아닌 여러개를 갖을 수 있도록 하여 트리 전체의 높이를 줄임
- B+Tree : 모든 노드에 데이터가 들어가는게 아니라, 리프 노드에만 데이터를 갖고 리프 노드를 연결해두는 것. 범위 탐색에 유리

### 클러스터드 인덱스
- 테이블 당 하나, 반드시 존재하는 인덱스로 테이블 생성시에 안만들어주면 알아서 생성
- 정렬이 되므로 하나만 존재할 수 있음
- 리프노드가 데이터 자체

### 넌클러스터드 인덱스
- 테이블에 여러개
- 리프노드는 데이터를 가리키는 포인트

### 인덱스를 사용하면 좋은 점
- Where 문에 사용해서 조건 검색을 빠르게
- 특정 컬럼을 기준으로 값을 정렬해서 얻어야 할 때
- 조인문에 특정 컬럼이 사용되는 경우

### 인덱스를 사용하면 좋지 않은 점
- 검색보다 삽입/삭제가 많은 경우
- 카디널리티가 낮아서 인덱스를 사용해도 대다수의 컬럼이 조건에 부합하게 되는 경우
- 멀티 컬럼 인덱스에서 컬럼 순서에 따라 쿼리하지 않아 제대로 인덱스를 활용하지 못하는 경우 

### 삽입/삭제에 비용이 드는 이유
- 애초에 또 다른 공간에 데이터를 기록 또는 삭제하니 공간과 시간 비용이 들 수 밖에 없다.
- 또 인덱스의 각 노드는 페이지로 되어있다.
- 이 페이지에도 크기가 정해져있고, 그 크기를 넘으면 페이지 분할이 발생한다.
- 페이지 분할은 또 하나의 페이지를 만들고 그에 맞춰 데이터 정렬이 이뤄진다.
- 최악의 경우 루트부터 리프 노드까지 전부 페이지 분할 처리가 필요할 수 있다.

### 가장 와닿았던 클러스터, 넌클러스터 인덱스 구조 그림
![image](https://github.com/ecsimsw/daily-note-public/assets/46060746/1bd6dce9-dd16-4c81-9458-41ad9147dd7e)

### 인덱스 수행 타입
- Index range scan : 인덱스로 범위의 시작 리프 노드를 찾고, 범위의 끝에 따라 리프노드를 수평 탐색한다.
- Index full scan : 인덱스 정렬 순서가 올바르지 않아 트리 검색을 하지 못하지만, 검색으로 인덱스 컬럼이 사용되어 인덱스로 모든 데이터를 훑는다.
- Index unique scan : 인덱스로 단일 항을 찾을 수 있다.
- Table full scan : 인덱스를 전혀 사용하지 못한다.

### Index range scan vs Index full scan
- range 스캔이 더 나을 것이다. 
- 데이터 양이 매우 작아서 리프 노드를 전부 수평 탐색하는 것이 나은 특수한 상황에선 또 모르겠다.
- 인덱스 사용 전략을 실행 계획으로 확인하여 인덱스를 수정하거나 여러 인덱스가 수행되는 상황에서 힌트를 주어 풀이할 수 있겠다.

### Index full scan vs Table full scan 
- 인덱스를 타는 것이 항상 좋은 것은 아니다.
- 카디널리티가 매우 작은 조건의 인덱스를 어중간하게 타서 대부분의 노드를 탐색하고, 또 다른 조건의 만족을 위해 결국 데이터를 확인하는 상황을 가정해보자. 오히려 그냥 데이터를 전체 탐색해서 바로 두 조건을 확인하는게 빠를 것이다. 
- 예를 들면 위 그림에서 MobileNo가 113 이상이면서 Age가 10이상인 사용자의 이름을 조회한다면? 거의 대부분의 넌클러스터드 인덱스를 탐색 후에 PK 를 확인해서 클러스터드 인덱스를 읽고 리프 노드까지 내려가서야 Age 를 조사할 것이다. (또는 넌클러스터에서 리프노드에 데이터 위치를 참고할 수도 있다)
- 검색 값이 많을 때는 인덱스 스캔보다 테이블 스캔이 더 빠를 수도 있다. 그 임계값이 보통 전체 데이터의 20%라는 얘기를 들었다.
- 또는 데이터가 너무 작을때도.

### 실행 계획으로 확인 할 것
- 멀티 컬럼 인덱스 그래서 컬럼을 여러개로 인덱스를 구성할 때는 그 순서가 중요하다. Index range scan 이 될 수도, Index full scan 이 될 수도 있으니 말이다.
- 실행 계획으로 인덱스 수행 타입과 확인해야 하는 로우 수, 사용되는 인덱스를 확인할 수 있다.
- 실행 계획은 (쿼리 파서, 전처리기, 옵티마이저, 실행기) 중 옵티마이저에서 어떤 인덱스를 어떤 순서로 검색할지 결정하게 된다.

### TIP :: 긴 텍스트
- 긴 텍스트의 경우 인덱스가 적용되기 어렵다.
- 원하는 것도 텍스트의 일부를 검색하는 것일테니.
- Full text index 를 알아보자. 긴 텍스트를 토큰으로 나눠 검색에 용이하게 처리한다고 한다.

### TIP :: 어떻게 지정하냐
- 클러스터드 인덱스는 알아서 걸리고, 직접 설정하고 싶거나 넌클러스터드 인덱스를 추가할 땐 테이블을 생성하거나 CREATE INDEX 로 추가

### TIP :: DDL, DML, DCL
```
DDL : Truncate, Create, Drop, Alter / 데이터 정의
DML : Insert, Delete, Select, Update / 데이터 관리
DCL : Commit, Rollback, Grant / 데이터의 접근 
```

### TIP :: Delete vs Drop vs Truncate
```
Delete : 데이터 로우를 삭제, 실제 용량이 줄어들지는 않고 느림
Truncate : 실제 Hdd 에서 데이터를 삭제하는데, 테이블 정의를 지우는지 않음
Drop : 테이블 정의까지 모두 날려버림
```
